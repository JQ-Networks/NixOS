{ config, pkgs, lib, ... }:
with lib;
let
  cfg = config.jq-networks.services.ddclient;
  boolToStr = bool: if bool then "yes" else "no";
  dataDir = "/var/lib/ddclient";

  configBase = ''
    # This file can be used as a template for configFile or is automatically generated by Nix options.
    cache=${dataDir}/ddclient.cache
    foreground=YES
  '';
  configHost = key: cfg: 
  ''
    ${lib.optionalString (cfg.use != "") "use=${cfg.use}"}
    ${lib.optionalString (cfg.interface != "" && !cfg.ipv6 && cfg.use == "cmd" && cfg.customCmd == "") 
    "cmd=\'${pkgs.iproute2}/bin/ip -f inet addr sh dev ${cfg.interface} scope global | grep -Po \\'inet \\\\K[\\\\d.]+\\'\'"}
    ${lib.optionalString (cfg.interface != "" && cfg.ipv6 && cfg.use == "cmd" && cfg.customCmd == "") 
    "cmd=\'${pkgs.iproute2}/bin/ip -f inet6 addr sh dev ${cfg.interface} scope global | grep -Po \\'inet6 \\\\K[\\\\da-f:]+\\'\'"}
    ${lib.optionalString (cfg.customCmd != "") "cmd=${cfg.cmd}"}
    login=${cfg.username}
    password=${cfg.password}
    protocol=${cfg.protocol}
    ${lib.optionalString (cfg.script != "") "script=${cfg.script}"}
    ${lib.optionalString (cfg.server != "") "server=${cfg.server}"}
    ${lib.optionalString (cfg.zone != "") "zone=${cfg.zone}"}
    ssl=${boolToStr cfg.ssl}
    wildcard=YES
    ipv6=${boolToStr cfg.ipv6}
    quiet=${boolToStr cfg.quiet}
    verbose=${boolToStr cfg.verbose}
    ${cfg.extraConfig}
    ${lib.concatStringsSep "," cfg.domains}
  '';

  hostType = with lib.types; lib.types.submodule {
    options = {
      domains = mkOption {
        default = [ "" ];
        type = listOf str;
        description = ''
          Domain name(s) to synchronize.
        '';
      };

      username = mkOption {
        default = "";
        type = str;
        description = ''
          User name.
        '';
      };

      password = mkOption {
        default = "";
        type = str;
        description = ''
          Password. WARNING: The password becomes world readable in the Nix store.
        '';
      };

      protocol = mkOption {
        default = "dyndns2";
        type = str;
        description = ''
          Protocol to use with dynamic DNS provider (see https://sourceforge.net/p/ddclient/wiki/protocols).
        '';
      };

      server = mkOption {
        default = "";
        type = str;
        description = ''
          Server address.
        '';
      };

      ssl = mkOption {
        default = true;
        type = bool;
        description = ''
          Whether to use SSL/TLS to connect to dynamic DNS provider.
        '';
      };

      ipv6 = mkOption {
        default = false;
        type = bool;
        description = ''
          Whether to use IPv6.
        '';
      };


      quiet = mkOption {
        default = false;
        type = bool;
        description = ''
          Print no messages for unnecessary updates.
        '';
      };

      script = mkOption {
        default = "";
        type = str;
        description = ''
          script as required by some providers.
        '';
      };

      use = mkOption {
        default = "web, web=ip.sb";
        type = str;
        description = ''
          Method to determine the IP address to send to the dynamic DNS provider.
          If you want to use interface or customCmd, specify "cmd".
        '';
      };

      interface = mkOption {
        type = types.str;
        default = "";
        description = ''
          Get public ip from this interface. IPv4 or IPv6 is decided by config "ipv6".
        '';
      };

      customCmd = mkOption {
        default = "";
        type = str;
        description = ''
          Scripts to determine the IP address.
          Only used when interface = null.
        '';
        example = ''
          To get ipv4 from pppoe-wan
          "\'${pkgs.iproute2}/bin/ip -f inet addr sh dev pppoe-wan scope global | grep -Po \\'inet \\\\K[\\\\d.]+\\'\'";
          To get ipv6 from pppoe-wan
          "\'${pkgs.iproute2}/bin/ip -f inet6 addr sh dev pppoe-wan scope global | grep -Po \\'inet6 \\\\K[\\\\da-f:]+\\'\'";
        '';
      };

      verbose = mkOption {
        default = true;
        type = bool;
        description = ''
          Print verbose information.
        '';
      };

      zone = mkOption {
        default = "";
        type = str;
        description = ''
          zone as required by some providers.
        '';
      };

      extraConfig = mkOption {
        default = "";
        type = lines;
        description = ''
          Extra configuration. Contents will be added verbatim to the configuration file.
        '';
      };
    };
  };
in
{
  ###### interface

  options = {

    jq-networks.services.ddclient = with lib.types; {

      enable = mkEnableOption "Whether to synchronise your machine's IP address with a dynamic DNS provider (e.g. dyndns.org).";

      hosts = mkOption {
        type = attrsOf hostType;
        description = "multiple instances";
      };

      configFile = mkOption {
        default = "/etc/ddclient.conf";
        type = path;
        description = ''
          Path to configuration file.
          When set to the default '/etc/ddclient.conf' it will be populated with the various other options in this module. When it is changed (for example: '/root/nixos/secrets/ddclient.conf') the file read directly to configure ddclient. This is a source of impurity.
          The purpose of this is to avoid placing secrets into the store.
        '';
        example = "/root/nixos/secrets/ddclient.conf";
      };

      interval = mkOption {
        default = "10min";
        type = str;
        description = ''
          The interval at which to run the check and update.
          See <command>man 7 systemd.time</command> for the format.
        '';
      };
    };
  };


  ###### implementation

  config = mkIf config.jq-networks.services.ddclient.enable {
    environment.etc."ddclient.conf" = {
      enable = cfg.configFile == "/etc/ddclient.conf";
      mode = "0600";
      text = configBase + (lib.concatStringsSep "\n" (mapAttrsToList configHost cfg.hosts));
    };

    systemd.services.ddclient = {
      description = "Dynamic DNS Client";
      wantedBy = [ "multi-user.target" ];
      after = [ "network.target" ];
      restartTriggers = [ config.environment.etc."ddclient.conf".source ];

      serviceConfig = rec {
        DynamicUser = true;
        RuntimeDirectory = StateDirectory;
        StateDirectory = builtins.baseNameOf dataDir;
        Type = "oneshot";
        ExecStartPre = "!${lib.getBin pkgs.coreutils}/bin/install -m666 ${cfg.configFile} /run/${RuntimeDirectory}/ddclient.conf";
        ExecStart = "${lib.getBin pkgs.ddclient}/bin/ddclient -file /run/${RuntimeDirectory}/ddclient.conf";
      };
    };

    systemd.timers.ddclient = {
      description = "Run ddclient";
      wantedBy = [ "timers.target" ];
      timerConfig = {
        OnBootSec = cfg.interval;
        OnUnitInactiveSec = cfg.interval;
      };
    };
  };
}
